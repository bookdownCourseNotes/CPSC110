--- 
title: "Systematic Program Design"
author: "Andrew Li"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "Fundamental program and computation structures. Introductory programming skills. Computation as a tool for information processing, simulation and modelling, and interacting with the world."
---

# Preamble

## Caution
**This book was made for studying purposes only.** I will be adding notes from other sources and I may leave out some topics from the course. Also, I will not be purchasing or reading the supplemental text. As such, this is not a faithful representation of the course. 


## Course content
<details>
<summary>Beginning student language</summary>
* Module overview
* Expressions
* Evaluations
* Strings and images
* Constant definitions
* Function definitions
* Booleans and if expressions
* Practice problems
</details>

<details>
<summary>How to design functions</summary>
* Module overview
* HtDF recipe
* A simple practice problem
* When tests are incorrect
* Varying recipe order
* Poorly formed problems
* Practice problems
</details>

<details>
<summary>How to design data </summary>
* Module overview
* cond expressions
* Data definitions
* Atomic non-distinct
* HtDF with non-primitive data
* HtDF X structure of data orthogonality
* Interval
* Enumeration
* Itemization
* HtDF with intervals
* HtDF with enumeration
* HtDF with itemization
* Structure of information flows through
* Practice problems
</details>

<details>
<summary> How tio design worlds</summary>
* Module overview
* Interactivce programs
* The big-bang mechanism
* Domain analysis
* Program through main function
* Working through the wish list
* Improving a world program - Add SPEED
* Improving a world program - Add a key handler
* Practice problems
</details>

<details>
<summary>Compound data</summary>
* Module overview
* Define-struct
* Compound data definitions 
* Practice problems - Compound data
* HtDW with compound data
* Practice problems - HtDW with compound data
</details>

<details>
<summary>How to design functions</summary>
* Module overview
* HtDF recipe
* A simple practice problem
* When tests are incorrect
* Varying recipe order
* Poorly formed problems
* Practice problems
</details>

<details>
<summary>Self-reference</summary>
* Module overview
* Introduction to arbitrary sized data
* List mechanisms
* List Data definitions 
* Function operating on list
* Revising the recipes for lists
* Designing with lists
* Positions in list templates
* Practice problems
</details>

<details>
<summary>Reference</summary>
* Module overview
* The reference rule part 1
* The reference rule part 2
* The reference rule part 3
* Practice problems
</details>

<details>
<summary>Naturals</summary>
* Module overview
* Natural numbers
* A parlor trick
* Practice problems
</details>

<details>
<summary>Helpers</summary>
* Module overview
* Introduction
* Function composition
* Laying out a list of images
* Operating on a list
* Domain knowledge shift
* The last helper
* Practice problems
</details>

<details>
<summary>Binary search trees</summary>
* Module overview
* List abbreviations
* List of account
* BSTs
* A data definition for BSTs
* Lookup on BSTs
* REndering BSTs
* Practice problems
</details>

<details>
<summary>Mutual reference</summary>
* Module overview
* Mutually recursive data
* Templating mutual recursion
* Functions on mutually recursive data part 1
* Functions on mutually recursive data part 2
* backtracking search
* Practice problems
</details>

<details>
<summary>Two one-of types</summary>
* Module overview
* Cross product table
* Cross product code
* Practice problems
</details>

<details>
<summary>Local</summary>
* Module overview
* Introduction
* Forming and intuition
* Lexical scoping
* Evaluation rules
* Encapsultaion
* Avoiding recomputation
* Practice problems
</details>

<details>
<summary>Abstraction</summary>
* Module overview
* Introduction
* From examples 1
* From examples 2
* From examples 3
* Using built in abstract functions
* Closures
* Fold functions
* Practice problems
</details>

<details>
<summary>Generative recursion</summary>
* Module overview
* Introduction
* Fractals
* Termination arguments
* Practice problems
</details>

<details>
<summary>Search</summary>
* Module overview
* Lambda expressions
* Introduction
* Sudoku -- Terminology
* Sudoku -- Data definitions and primitives
* Sudoku -- The search intuition
* Sudoku -- Making the wish list
* Sudoku -- Making a wish come true part 1
* Sudoku -- Making a wish come true part 2
* Sudoku -- Making a wish come true part 3
* Practice problems
</details>

<details>
<summary> Accumulators</summary>
* Module overview
* Context preserving accumulators
* Sample problem: skipn
* Tail recursion
* Worklist accumulators 1
* Worklist accumulators 2
* Practice problems
</details>

<details>
<summary>Graphs</summary>
* Module overview
* Introduction
* Constructing cyclic data
* Templating
Problem: reachable? 
* Practice problems
</details>